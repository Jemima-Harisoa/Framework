Sprint 3 : 
objectif : 
RedirectionServlet doit a son initialisation faire le scan des fichiers de test-framework
selon la structure de ce dernier. 
Ce qu'il faut faire: avec les classe de look up on lance une recherche du systeme de fichier 
dans le classpath du projet web, on voit si il y a des classes qui appel le controller qu'on
a fait dans annotations
une foit les classe troue on va juste les listes avec un out.print en plain text dans le navigateur 
web quand on appelle le servlet. 

Sprint 5 :
objectif: 
Envoye des données vers les pages jsp : ex: liste des produits

Ce qu'il se passe : 
- Le client envoit une requet de type get
- Le front servlet fait la redirection vers les controller deleger et map l'url a une fonction
- La fonction est executer cf Sprint 4
- On envoye les donne avec la Classe view
- Le retour est receptionner et deleguer au servlet 
    - Avec getTemplate on obtien le path vers le fichiers
    - Avec getData on obtient les donne a envoye 
    - Avec getName on obtient le nom de la variable 
- Enfin le tout est envoye vers la page avec dispatcher

Ce qu'il faut faire: 
- Dans RedirectionServlet:
    + il faut une fonction qui va receptionner et recuperer les view et appeler le dispatcher
    + il faut un if-else pour differntier les retour de type string et view apres execution dans
    doService 


Sprint 3 ter: 
objectif: mettre en place un url dynamique (ex: /products/{id})

Ce qu'il se passe : 
- l'info dans {} sera traiter comme une variable 
    + on doit pouvoir recuperer cette variable dans la fonction du controller
    + on doit pouvoir l'utiliser dans la fonction avant invoke dans executeMappedMethod
    + dans les fonctions mapper dans le controller : la fonction avec le type d'url a accolade recupere un/des 
    parametres 
    
Ce qu'il faut faire:
- Determiner la partie de l'url qui contient cette partie (ex: /products/12 est maper avec /products/{id})
    + voir dans le cas ou il y a une accolade l'url est reconnu comme flexible elle pourra ette mapper avec un url qui presente des similitude avec celle ci  (ex: si on /products/12/categorie est maper avec /products/{id}/categorie/{idcategorie}) => on peut d'abords voir les url de type /products/ et on continue a concatener 
    suivant l'url demande 
    + MappedMethod dans MappingAnalyzer est cence avoir une liste d'argument pour chaque mapped methode 
    en faisant un explode sur l'url =>  /products/{id}/categorie/{idcategorie} => on a 2 argument id et idcategorie on fait un substring  et on note ou les accolade se trouve id get(1) et idcategorie get (3) 
    + lorsqu'on recoit une url on la traite avec un substring de meme sorte que les partie qui corresponnde sont definit comme argument 
    + a l'execution de la methode les argument si il y en a sont integrer a la methode 
- Recuperer la variable et la placer en argument dans la fonction invoquer 
- Le proceessus restant suivent leur cours (cf sprint 5)


Sprint 6 :
objectif: 
Envoye des données vers les servlets : ex formulaire de log in 

Ce qu'il ce passe : 
- Le client envoit une requet post ou get 
- Les données demandée peuvent se trouver dans l'url (format rest)
- Il faut traiter la requete http directement et recuperer les donees 
- Une fois obtenu les donnees sont traiter dans les controllers 

Ce qu'il faut faire: 
- Dans RedirectionServlet:
    + reception des donne de la page view 
    + appelle de la fonction qui va traiter les donne avec invoke et les data transmit seront les parametre
    + traitement de retour de la fonction cf sprint 5 

2- Spécification du traitement de donné: 
Sachant que Les données envoye depuis le formulaire sont deja mapper avec un controller: 
    + Établir un system associatif de nom avec annotation @RequestParam (a créer) ex : si dans formulaire, attribut name='prenom' et name='id' on match ces valeur avec les attributs demander par les fonction le cast sera avalue par rapport au type => raise exception faitre correspondre les argument avec le bon type
    
    <form method="POST" action="/products">
        <label for="productName">Nom du produit:</label>
        <input type="text" id="productName" name="id" required />
        <button type="submit">Ajouter</button>
    </form>

    @Mapping("/products") // default method get
    public View getProduct(@Requeastparam int id) {// @Requeastparam=> optionnel 
        // Logic metier 
        return new View("product", "product", this.productList.get(index)); // ici le nom de la vue dans le dossier webapps
    }

    + A defaut d'avoir une coordination nom et argument on fait un machin des argument avec les types => @Requestparam prend l'argument pour donner le nom coordonner avec l'attribut et la variable

    @Mapping("/products") // default method get
    public View getProduct(int index) {
        // Logic metier 
        return new View("product", "product", this.productList.get(index)); // ici le nom de la vue dans le dossier webapps
    }

Sprint 7 :
Mettre une distinction entre get et post mapping 

Sprint 8 :
objectif: Construction d'un map pour gerer les donne envoyer via formulaire (post et get)
Ce qu'il se passe : 
- Les données envoyées via un formulaire POST ou GET sont récupérées dans la requête HTTP
- Ces données doivent être mappées à des paramètres de méthode dans les contrôleurs
- Un map est créé pour stocker les paramètres nommés et leurs valeurs extraites de la requête
- Lors de l'appel à une méthode annotée, ces paramètres sont passés en argument

Ce qu'il faut faire:
La fonctioon invoquer est decrite comme suit : 
    + Dans RedirectionServlet, lors du traitement d'une requête POST ou GET, extraire les paramètres de la requête et les stocker dans un Map<String, Object>
    + Lors de l'invocation de la méthode mappée, vérifier si elle accepte un Map<String, Object> comme paramètre => n'importe quelle type de map ne devrait pas forcement etre de type string object si le type est clairement definit et non un simple object la logic est différente
    + Si oui, passer ce map lors de l'appel à la méthode
@PostMapping("/products/create")
public View createProduct(Map<String, Object> params) {  // Utilise "quantity" comme nom
    String productName = (String) params.get("name");
    double price = (Double) params.get("price");
    int quantity = (Integer) params.get("quantity");
    Product product = new Product(productName, price, quantity);
    productService.addProduct(product);
    return new View("success", "Product created successfully");
}

Sprint 8 bis:
Objectif: Gestion des types primitifs et des objets complexes dans les paramètres de méthode
Ce qu'il se passe :
- Les méthodes des contrôleurs peuvent accepter des types primitifs (int, double, etc.) ou des objets complexes (User, Product, etc.) comme paramètres
- Lors de l'invocation de ces méthodes, les paramètres doivent être correctement mappés et convertis en fonction de leur type
- Un mécanisme de conversion est mis en place pour gérer cette diversité de types 
- Le binding d'objet complexe est etablit  apartir du formulaire on fesant une correspondance entre les champs du formulaire et les attributs de la méthode
Ce qu'il faut faire:
- Dans RedirectionServlet, lors de l'invocation d'une méthode mappée, analyser les paramètres attendus
- Pour chaque paramètre, vérifier son type
    + Si c'est un type primitif, extraire la valeur correspondante de la requête et la convertir
    + Si c'est un objet complexe, créer une instance de cet objet et remplir ses attributs en fonction des données de la requête cf mapping fait dans le sprint 8
- Il devrait donc y a voir de quoi matcher proprement les variable et les attribut a partir des nomencalture donne cote vue
ex : <input name='Products.id' >

Sprint 9: 
Objectif: Possibilité d'exposition  d'api rest  
Ce qu'il se passe :
- Les contrôleurs peuvent exposer des API REST en plus des vues JSP
- Les méthodes annotées peuvent retourner des objets qui seront sérialisés en JSON
- Le client peut consommer ces API via des requêtes HTTP

Ce qu'il faut faire:
- Dans RedirectionServlet, après l'invocation d'une méthode mappée, vérifier le type de retour
    + Si le type de retour est un objet (et non une vue), sérialiser cet objet en JSON
    + Envoyer la réponse JSON au client avec le bon en-tête HTTP (Content-Type: application/json)
@JsonMapping("/api/products/{id}")
@GetMapping("/api/products/{id}")
public Product getProductApi(@PathVariable int id) {
    return productService.getProductById(id); // Retourne un objet Product qui sera sérialisé en JSON
}

Serialization json a implementer avec une librairie externe type gson ou jackson :
ex avec gson :
Gson gson = new Gson();
String jsonResponse = gson.toJson(yourObject);
response.setContentType("application/json");
response.getWriter().write(jsonResponse);

Sprint 10 :
Objectif: Échange de fichier entre les vues et les controllers
Ce qu'il se passe :
- Les utilisateurs peuvent télécharger des fichiers via des formulaires dans les vues JSP
- Les contrôleurs peuvent traiter ces fichiers (enregistrement, analyse, etc.)
- Un mécanisme de gestion des fichiers est mis en place pour faciliter cet échange
Ce qu'il faut faire:
- Dans RedirectionServlet, lors de la réception d'une requête contenant un fichier, extraire le fichier de la requête
- Passer le fichier en tant que paramètre à la méthode mappée dans le contrôleur 
- Se referer au sprint 8 et 8 bis en ajoutant les fallback dans les cas ou les donne envoye sont des / est un ficchier   

Exemple de code pour un controller qui gère l'upload de fichier :
@PostMapping("/upload")
public View handleFileUpload(@RequestParam("file") MultipartFile file) {
    // Logique pour traiter le fichier
    fileService.saveFile(file);
    return new View("uploadSuccess", "File uploaded successfully");
}

Sprint 11:
Objectif: mis en place de gestion de session 
Ce qu'il se passe :
- Les utilisateurs peuvent communiquer des informations de session maintenues entre les requêtes

Ce qu'il faut faire:
Point d’injection : juste avant l’appel de la méthode dans le Front Controller (RedirectionServlet)
Annotation @Session : indique l’intention, priorité sur le nom
Annotation @SessionParam : injecte la valeur de session, création automatique si elle n’existe pas encore
Nom de la session : priorité à l’annotation, sinon nom du paramètre
Types autorisés : objets ou wrappers (Integer, Boolean, etc.), pas de primitifs
Multiple @SessionParam : autorisé par méthode, chaque clé distincte dans la session
Isolation : chaque sessionId a sa propre Map (Map<String,Object>), jamais de static global pour les données utilisateur
Extensible : aujourd’hui Map, demain HttpSession, Redis ou autre